#!/usr/bin/env python3
"""
{{ service_name }} Agent
Generated by Service Template Generator - Agent-Controller Pattern

This agent receives tasks from the controller via RabbitMQ and executes them.
It supports RBAC, OAuth2 authentication, and real-time result streaming.
"""

import os
import sys
import json
import pika
import time
import logging
import subprocess
import threading
from datetime import datetime
{% if enable_oauth -%}
import requests
from jose import jwt
{% endif -%}

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s [%(name)s] %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('{{ service_name_snake }}_agent')

class {{ service_name_camel }}Agent:
    def __init__(self):
        """Initialize the agent with configuration from environment variables"""
        
        # RabbitMQ configuration
        self.rabbitmq_host = os.environ.get('RABBITMQ_HOST', 'localhost')
        self.rabbitmq_port = int(os.environ.get('RABBITMQ_PORT', 5672))
        self.rabbitmq_user = os.environ.get('RABBITMQ_USER', 'rabbitmq')
        self.rabbitmq_password = os.environ.get('RABBITMQ_PASSWORD', 'rabbitmq')
        self.rabbitmq_vhost = os.environ.get('RABBITMQ_VHOST', '/')
        
        # Queue configuration
        self.command_queue = os.environ.get('COMMAND_QUEUE', '{{ service_name_snake }}_commands')
        self.result_queue = os.environ.get('RESULT_QUEUE', '{{ service_name_snake }}_results')
        
        # Agent identification
        self.agent_id = os.environ.get('AGENT_ID', f'{{ service_name_kebab }}-agent-{os.getpid()}')
        self.node_name = os.environ.get('NODE_NAME', 'unknown-node')
        
        {% if enable_oauth -%}
        # OAuth/OIDC configuration
        self.oauth_issuer = os.environ.get('OAUTH_ISSUER', '{{ oauth_issuer }}')
        self.oauth_client_id = os.environ.get('OAUTH_CLIENT_ID', '{{ oauth_client_id }}')
        self.required_group = os.environ.get('REQUIRED_GROUP', 'administrators')
        
        # JWT validation
        self.jwks_cache = None
        self.jwks_cache_time = 0
        self.jwks_cache_ttl = 3600  # 1 hour
        {% endif -%}
        
        # RBAC configuration (fallback for development)
        self.rbac_config = {
            'administrators': ['*'],  # All commands
            'operators': ['ls', 'ps', 'df', 'uptime', 'whoami'],
            'viewers': ['ls', 'whoami']
        }
        
        # Connection objects
        self.connection = None
        self.channel = None
        
        logger.info(f'{{ service_name_camel }} Agent initialized: {self.agent_id} on {self.node_name}')
    
    def connect_rabbitmq(self):
        """Establish connection to RabbitMQ"""
        try:
            credentials = pika.PlainCredentials(self.rabbitmq_user, self.rabbitmq_password)
            parameters = pika.ConnectionParameters(
                host=self.rabbitmq_host,
                port=self.rabbitmq_port,
                virtual_host=self.rabbitmq_vhost,
                credentials=credentials,
                heartbeat=600,
                blocked_connection_timeout=300
            )
            
            self.connection = pika.BlockingConnection(parameters)
            self.channel = self.connection.channel()
            
            # Declare queues
            self.channel.queue_declare(queue=self.command_queue, durable=True)
            self.channel.queue_declare(queue=self.result_queue, durable=True)
            
            logger.info(f'Connected to RabbitMQ: {self.rabbitmq_host}:{self.rabbitmq_port}')
            
        except Exception as e:
            logger.error(f'Failed to connect to RabbitMQ: {str(e)}')
            raise
    
    {% if enable_oauth -%}
    def get_jwks(self):
        """Get JWKS keys from OAuth provider with caching"""
        current_time = time.time()
        
        if self.jwks_cache and (current_time - self.jwks_cache_time) < self.jwks_cache_ttl:
            return self.jwks_cache
        
        try:
            # Get OIDC configuration
            oidc_url = f'{self.oauth_issuer}/.well-known/openid-configuration'
            oidc_config = requests.get(oidc_url, timeout=10).json()
            jwks_uri = oidc_config['jwks_uri']
            
            # Get JWKS
            jwks_response = requests.get(jwks_uri, timeout=10)
            self.jwks_cache = jwks_response.json()
            self.jwks_cache_time = current_time
            
            logger.info('JWKS keys updated from OAuth provider')
            return self.jwks_cache
            
        except Exception as e:
            logger.error(f'Failed to fetch JWKS: {str(e)}')
            return {'keys': []}
    
    def verify_jwt_token(self, token):
        """Verify JWT token and extract user information"""
        try:
            # Get JWKS keys
            jwks = self.get_jwks()
            
            # Decode token header
            unverified_header = jwt.get_unverified_header(token)
            
            # Find matching key
            key = None
            for jwk_key in jwks['keys']:
                if jwk_key['kid'] == unverified_header['kid']:
                    key = jwk_key
                    break
            
            if not key:
                raise ValueError('No matching key found in JWKS')
            
            # Verify and decode token
            payload = jwt.decode(
                token,
                key,
                algorithms=['RS256'],
                audience=self.oauth_client_id,
                issuer=self.oauth_issuer
            )
            
            return payload
            
        except jwt.JWTError as e:
            logger.warning(f'JWT verification failed: {str(e)}')
            return None
        except Exception as e:
            logger.error(f'Token verification error: {str(e)}')
            return None
    
    def get_user_groups(self, token):
        """Extract user groups from JWT token"""
        try:
            payload = self.verify_jwt_token(token)
            if not payload:
                return []
            
            # Extract groups from token
            groups = payload.get('groups', [])
            if isinstance(groups, str):
                groups = [groups]
            
            # Also check realm_access roles
            realm_access = payload.get('realm_access', {})
            roles = realm_access.get('roles', [])
            
            # Combine groups and roles
            all_groups = list(set(groups + roles))
            
            logger.debug(f'User groups extracted: {all_groups}')
            return all_groups
            
        except Exception as e:
            logger.error(f'Failed to extract user groups: {str(e)}')
            return []
    {% endif -%}
    
    def is_command_authorized(self, command, user_groups):
        """Check if user is authorized to execute the command"""
        if not user_groups:
            return False
        
        # Extract command name (first word)
        cmd_name = command.strip().split()[0] if command.strip() else ''
        
        # Check each group's permissions
        for group in user_groups:
            if group in self.rbac_config:
                allowed_commands = self.rbac_config[group]
                
                # Administrators can run anything
                if '*' in allowed_commands:
                    return True
                
                # Check specific command permission
                if cmd_name in allowed_commands:
                    return True
        
        return False
    
    def execute_command(self, command, task_id, user_info):
        """Execute a command and stream results"""
        try:
            logger.info(f'Executing command: {command} (task: {task_id})')
            
            # Send start notification
            self.send_result(task_id, 'started', {
                'message': f'Starting command: {command}',
                'timestamp': datetime.utcnow().isoformat(),
                'agent_id': self.agent_id,
                'node_name': self.node_name
            })
            
            # Execute command with streaming output
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            # Stream output in real-time
            output_lines = []
            for line in iter(process.stdout.readline, ''):
                line = line.rstrip()
                if line:
                    output_lines.append(line)
                    self.send_result(task_id, 'output', {
                        'line': line,
                        'timestamp': datetime.utcnow().isoformat()
                    })
            
            # Wait for process completion
            process.stdout.close()
            return_code = process.wait()
            
            # Send completion notification
            self.send_result(task_id, 'completed', {
                'return_code': return_code,
                'output': '\\n'.join(output_lines),
                'timestamp': datetime.utcnow().isoformat(),
                'success': return_code == 0
            })
            
            logger.info(f'Command completed: {command} (return code: {return_code})')
            
        except Exception as e:
            logger.error(f'Command execution failed: {str(e)}')
            self.send_result(task_id, 'error', {
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            })
    
    def send_result(self, task_id, status, data):
        """Send execution result back to controller"""
        try:
            result_message = {
                'task_id': task_id,
                'agent_id': self.agent_id,
                'node_name': self.node_name,
                'status': status,
                'data': data,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            self.channel.basic_publish(
                exchange='',
                routing_key=self.result_queue,
                body=json.dumps(result_message),
                properties=pika.BasicProperties(
                    delivery_mode=2,  # Make message persistent
                    content_type='application/json'
                )
            )
            
        except Exception as e:
            logger.error(f'Failed to send result: {str(e)}')
    
    def process_message(self, ch, method, properties, body):
        """Process incoming command messages"""
        try:
            # Parse message
            message = json.loads(body.decode('utf-8'))
            
            task_id = message.get('task_id')
            command = message.get('command')
            user_token = message.get('token')
            user_info = message.get('user_info', {})
            
            logger.info(f'Received task: {task_id} - {command}')
            
            {% if enable_oauth -%}
            # Verify authentication
            if user_token:
                user_groups = self.get_user_groups(user_token)
                user_info['groups'] = user_groups
            else:
                logger.warning(f'No authentication token provided for task: {task_id}')
                self.send_result(task_id, 'error', {
                    'error': 'Authentication token required',
                    'timestamp': datetime.utcnow().isoformat()
                })
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return
            
            # Check authorization
            if not self.is_command_authorized(command, user_groups):
                logger.warning(f'Command not authorized: {command} for groups: {user_groups}')
                self.send_result(task_id, 'error', {
                    'error': 'Command not authorized for your user groups',
                    'command': command,
                    'user_groups': user_groups,
                    'timestamp': datetime.utcnow().isoformat()
                })
                ch.basic_ack(delivery_tag=method.delivery_tag)
                return
            {% else -%}
            # No authentication - allow all commands (development mode)
            user_groups = ['administrators']
            {% endif -%}
            
            # Execute command in separate thread
            execution_thread = threading.Thread(
                target=self.execute_command,
                args=(command, task_id, user_info)
            )
            execution_thread.start()
            
            # Acknowledge message
            ch.basic_ack(delivery_tag=method.delivery_tag)
            
        except Exception as e:
            logger.error(f'Failed to process message: {str(e)}')
            ch.basic_ack(delivery_tag=method.delivery_tag)
    
    def start_consuming(self):
        """Start consuming messages from the command queue"""
        try:
            # Set up consumer
            self.channel.basic_qos(prefetch_count=1)
            self.channel.basic_consume(
                queue=self.command_queue,
                on_message_callback=self.process_message
            )
            
            logger.info(f'Agent {self.agent_id} started consuming from {self.command_queue}')
            logger.info('Waiting for commands. To exit press CTRL+C')
            
            # Start consuming
            self.channel.start_consuming()
            
        except KeyboardInterrupt:
            logger.info('Received interrupt signal, stopping agent...')
            self.channel.stop_consuming()
            self.connection.close()
        except Exception as e:
            logger.error(f'Consuming failed: {str(e)}')
            raise
    
    def health_check(self):
        """Perform health check"""
        try:
            # Check RabbitMQ connection
            if not self.connection or self.connection.is_closed:
                return False
            
            # Send heartbeat result
            self.send_result('health_check', 'heartbeat', {
                'agent_id': self.agent_id,
                'node_name': self.node_name,
                'status': 'healthy',
                'timestamp': datetime.utcnow().isoformat()
            })
            
            return True
            
        except Exception as e:
            logger.error(f'Health check failed: {str(e)}')
            return False

def main():
    """Main function to start the agent"""
    try:
        # Create and configure agent
        agent = {{ service_name_camel }}Agent()
        
        # Connect to RabbitMQ
        agent.connect_rabbitmq()
        
        # Start health check thread
        def health_check_loop():
            while True:
                agent.health_check()
                time.sleep(30)  # Health check every 30 seconds
        
        health_thread = threading.Thread(target=health_check_loop, daemon=True)
        health_thread.start()
        
        # Start consuming messages
        agent.start_consuming()
        
    except Exception as e:
        logger.error(f'Agent startup failed: {str(e)}')
        sys.exit(1)

if __name__ == '__main__':
    main()
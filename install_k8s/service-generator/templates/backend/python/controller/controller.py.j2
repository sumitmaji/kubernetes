#!/usr/bin/env python3
"""
{{ service_name }} Controller Backend
Generated by Service Template Generator - Agent-Controller Pattern

This controller manages agents via RabbitMQ and provides a web interface
for submitting tasks and monitoring results in real-time.
"""

import os
import sys
import json
import uuid
import pika
import time
import logging
import threading
from datetime import datetime
from functools import wraps

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO, emit, join_room, leave_room
{% if enable_oauth -%}
import requests
from jose import jwt
{% endif -%}

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s [%(name)s] %(message)s'
)
logger = logging.getLogger('{{ service_name_snake }}_controller')

class {{ service_name_camel }}Controller:
    def __init__(self):
        """Initialize the controller with configuration"""
        
        # RabbitMQ configuration
        self.rabbitmq_host = os.environ.get('RABBITMQ_HOST', 'localhost')
        self.rabbitmq_port = int(os.environ.get('RABBITMQ_PORT', 5672))
        self.rabbitmq_user = os.environ.get('RABBITMQ_USER', 'rabbitmq')
        self.rabbitmq_password = os.environ.get('RABBITMQ_PASSWORD', 'rabbitmq')
        self.rabbitmq_vhost = os.environ.get('RABBITMQ_VHOST', '/')
        
        # Queue configuration
        self.command_queue = os.environ.get('COMMAND_QUEUE', '{{ service_name_snake }}_commands')
        self.result_queue = os.environ.get('RESULT_QUEUE', '{{ service_name_snake }}_results')
        
        {% if enable_oauth -%}
        # OAuth/OIDC configuration
        self.oauth_issuer = os.environ.get('OAUTH_ISSUER', '{{ oauth_issuer }}')
        self.oauth_client_id = os.environ.get('OAUTH_CLIENT_ID', '{{ oauth_client_id }}')
        
        # JWT validation cache
        self.jwks_cache = None
        self.jwks_cache_time = 0
        self.jwks_cache_ttl = 3600
        {% endif -%}
        
        # Connection objects
        self.connection = None
        self.channel = None
        
        # Active tasks tracking
        self.active_tasks = {}
        self.connected_clients = set()
        
        logger.info('{{ service_name_camel }} Controller initialized')
    
    def connect_rabbitmq(self):
        """Connect to RabbitMQ"""
        try:
            credentials = pika.PlainCredentials(self.rabbitmq_user, self.rabbitmq_password)
            parameters = pika.ConnectionParameters(
                host=self.rabbitmq_host,
                port=self.rabbitmq_port,
                virtual_host=self.rabbitmq_vhost,
                credentials=credentials,
                heartbeat=600,
                blocked_connection_timeout=300
            )
            
            self.connection = pika.BlockingConnection(parameters)
            self.channel = self.connection.channel()
            
            # Declare queues
            self.channel.queue_declare(queue=self.command_queue, durable=True)
            self.channel.queue_declare(queue=self.result_queue, durable=True)
            
            logger.info(f'Connected to RabbitMQ: {self.rabbitmq_host}:{self.rabbitmq_port}')
            
        except Exception as e:
            logger.error(f'Failed to connect to RabbitMQ: {str(e)}')
            raise
    
    {% if enable_oauth -%}
    def get_jwks(self):
        """Get JWKS keys with caching"""
        current_time = time.time()
        
        if self.jwks_cache and (current_time - self.jwks_cache_time) < self.jwks_cache_ttl:
            return self.jwks_cache
        
        try:
            oidc_url = f'{self.oauth_issuer}/.well-known/openid-configuration'
            oidc_config = requests.get(oidc_url, timeout=10).json()
            jwks_uri = oidc_config['jwks_uri']
            
            jwks_response = requests.get(jwks_uri, timeout=10)
            self.jwks_cache = jwks_response.json()
            self.jwks_cache_time = current_time
            
            return self.jwks_cache
            
        except Exception as e:
            logger.error(f'Failed to fetch JWKS: {str(e)}')
            return {'keys': []}
    
    def verify_jwt_token(self, token):
        """Verify JWT token"""
        try:
            jwks = self.get_jwks()
            unverified_header = jwt.get_unverified_header(token)
            
            key = None
            for jwk_key in jwks['keys']:
                if jwk_key['kid'] == unverified_header['kid']:
                    key = jwk_key
                    break
            
            if not key:
                return None
            
            payload = jwt.decode(
                token,
                key,
                algorithms=['RS256'],
                audience=self.oauth_client_id,
                issuer=self.oauth_issuer
            )
            
            return payload
            
        except Exception as e:
            logger.error(f'JWT verification failed: {str(e)}')
            return None
    {% endif -%}
    
    def send_command(self, command, user_token=None, user_info=None):
        """Send command to agents via RabbitMQ"""
        try:
            task_id = str(uuid.uuid4())
            
            message = {
                'task_id': task_id,
                'command': command,
                'timestamp': datetime.utcnow().isoformat(),
                'user_info': user_info or {}
            }
            
            if user_token:
                message['token'] = user_token
            
            # Track task
            self.active_tasks[task_id] = {
                'command': command,
                'timestamp': message['timestamp'],
                'status': 'queued',
                'user_info': user_info
            }
            
            # Send to command queue
            self.channel.basic_publish(
                exchange='',
                routing_key=self.command_queue,
                body=json.dumps(message),
                properties=pika.BasicProperties(
                    delivery_mode=2,
                    content_type='application/json'
                )
            )
            
            logger.info(f'Command queued: {task_id} - {command}')
            return task_id
            
        except Exception as e:
            logger.error(f'Failed to send command: {str(e)}')
            raise
    
    def start_result_consumer(self, socketio):
        """Start consuming results from agents"""
        def consume_results():
            try:
                # Create separate connection for result consumption
                credentials = pika.PlainCredentials(self.rabbitmq_user, self.rabbitmq_password)
                parameters = pika.ConnectionParameters(
                    host=self.rabbitmq_host,
                    port=self.rabbitmq_port,
                    virtual_host=self.rabbitmq_vhost,
                    credentials=credentials
                )
                
                connection = pika.BlockingConnection(parameters)
                channel = connection.channel()
                
                def process_result(ch, method, properties, body):
                    try:
                        result = json.loads(body.decode('utf-8'))
                        task_id = result.get('task_id')
                        
                        if task_id in self.active_tasks:
                            # Update task status
                            self.active_tasks[task_id]['last_update'] = datetime.utcnow().isoformat()
                            self.active_tasks[task_id]['status'] = result.get('status')
                            
                            # Emit to WebSocket clients
                            socketio.emit('task_result', result, room='task_updates')
                            
                            # Remove completed tasks
                            if result.get('status') in ['completed', 'error']:
                                # Keep for a short time for final updates
                                pass
                        
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                        
                    except Exception as e:
                        logger.error(f'Failed to process result: {str(e)}')
                        ch.basic_ack(delivery_tag=method.delivery_tag)
                
                channel.basic_consume(
                    queue=self.result_queue,
                    on_message_callback=process_result
                )
                
                logger.info('Started result consumer')
                channel.start_consuming()
                
            except Exception as e:
                logger.error(f'Result consumer failed: {str(e)}')
        
        # Start consumer in background thread
        consumer_thread = threading.Thread(target=consume_results, daemon=True)
        consumer_thread.start()

# Create Flask application
app = Flask(__name__, static_folder='static')
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key')

# Configure CORS
CORS(app, origins="*", supports_credentials=True)

# Initialize SocketIO
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')

# Create controller instance
controller = {{ service_name_camel }}Controller()

# Connect to RabbitMQ on startup
try:
    controller.connect_rabbitmq()
    controller.start_result_consumer(socketio)
except Exception as e:
    logger.error(f'Failed to initialize controller: {str(e)}')
    sys.exit(1)

{% if enable_oauth -%}
def require_auth(f):
    """Decorator to require authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization', '')
        
        if not auth_header.startswith('Bearer '):
            return jsonify({'error': 'Authentication required'}), 401
        
        token = auth_header.split(' ', 1)[1]
        payload = controller.verify_jwt_token(token)
        
        if not payload:
            return jsonify({'error': 'Invalid token'}), 401
        
        request.user = payload
        request.token = token
        return f(*args, **kwargs)
    
    return decorated_function
{% else -%}
def require_auth(f):
    """Placeholder decorator when OAuth is disabled"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Mock user for development
        request.user = {'sub': 'dev-user', 'name': 'Development User'}
        request.token = 'dev-token'
        return f(*args, **kwargs)
    
    return decorated_function
{% endif -%}

# API Routes
@app.route('/health')
def health_check():
    """Health check endpoint"""
    try:
        # Check RabbitMQ connection
        rabbitmq_healthy = controller.connection and not controller.connection.is_closed
        
        return jsonify({
            'status': 'healthy' if rabbitmq_healthy else 'unhealthy',
            'service': '{{ service_name }}',
            'component': 'controller',
            'version': '{{ version }}',
            'timestamp': datetime.utcnow().isoformat(),
            'rabbitmq_connected': rabbitmq_healthy,
            'active_tasks': len(controller.active_tasks)
        })
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500

@app.route('/api/v1/tasks', methods=['POST'])
@require_auth
def submit_task():
    """Submit a new task to agents"""
    try:
        data = request.get_json()
        command = data.get('command')
        
        if not command:
            return jsonify({'error': 'Command is required'}), 400
        
        # Submit task
        task_id = controller.send_command(
            command=command,
            user_token=getattr(request, 'token', None),
            user_info=getattr(request, 'user', {})
        )
        
        return jsonify({
            'task_id': task_id,
            'command': command,
            'status': 'queued',
            'timestamp': datetime.utcnow().isoformat()
        })
        
    except Exception as e:
        logger.error(f'Failed to submit task: {str(e)}')
        return jsonify({'error': str(e)}), 500

@app.route('/api/v1/tasks', methods=['GET'])
@require_auth
def list_tasks():
    """List active tasks"""
    try:
        return jsonify({
            'tasks': controller.active_tasks,
            'count': len(controller.active_tasks)
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/v1/tasks/<task_id>', methods=['GET'])
@require_auth
def get_task(task_id):
    """Get specific task details"""
    try:
        task = controller.active_tasks.get(task_id)
        if not task:
            return jsonify({'error': 'Task not found'}), 404
        
        return jsonify(task)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# WebSocket Events
@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    logger.info(f'Client connected: {request.sid}')
    controller.connected_clients.add(request.sid)
    join_room('task_updates')
    
    # Send current active tasks
    emit('active_tasks', {
        'tasks': controller.active_tasks,
        'count': len(controller.active_tasks)
    })

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    logger.info(f'Client disconnected: {request.sid}')
    controller.connected_clients.discard(request.sid)
    leave_room('task_updates')

@socketio.on('submit_command')
def handle_submit_command(data):
    """Handle command submission via WebSocket"""
    try:
        command = data.get('command')
        auth_token = data.get('token')
        
        if not command:
            emit('error', {'message': 'Command is required'})
            return
        
        {% if enable_oauth -%}
        # Verify authentication
        if auth_token:
            user_info = controller.verify_jwt_token(auth_token)
            if not user_info:
                emit('error', {'message': 'Invalid authentication token'})
                return
        else:
            emit('error', {'message': 'Authentication token required'})
            return
        {% else -%}
        # Development mode
        user_info = {'sub': 'dev-user', 'name': 'Development User'}
        auth_token = 'dev-token'
        {% endif -%}
        
        # Submit command
        task_id = controller.send_command(
            command=command,
            user_token=auth_token,
            user_info=user_info
        )
        
        emit('task_submitted', {
            'task_id': task_id,
            'command': command,
            'status': 'queued'
        })
        
    except Exception as e:
        emit('error', {'message': str(e)})

{% if has_frontend -%}
# Serve frontend static files
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve_frontend(path):
    """Serve frontend files"""
    if path and os.path.exists(os.path.join(app.static_folder, path)):
        return send_from_directory(app.static_folder, path)
    return send_from_directory(app.static_folder, 'index.html')
{% endif -%}

if __name__ == '__main__':
    port = int(os.environ.get('PORT', {{ backend_port }}))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    logger.info(f'Starting {{ service_name_camel }} Controller on port {port}')
    
    socketio.run(
        app,
        host='0.0.0.0',
        port=port,
        debug=debug,
        allow_unsafe_werkzeug=True
    )
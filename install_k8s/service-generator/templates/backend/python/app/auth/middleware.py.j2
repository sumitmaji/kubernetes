"""
{{ service_name }} Authentication Middleware
Generated by Service Template Generator

This module provides OAuth/OIDC authentication middleware for protecting endpoints.
"""

{% if enable_oauth -%}
from functools import wraps
from flask import request, jsonify, current_app, g
import jwt
from jwt import PyJWKClient
import requests
from jose import jwt as jose_jwt, JWTError
import logging

logger = logging.getLogger(__name__)

class AuthenticationError(Exception):
    """Custom authentication error"""
    pass

def get_jwks_client():
    """Get JWKS client for JWT verification"""
    jwks_uri = current_app.config['OAUTH_JWKS_URI']
    return PyJWKClient(jwks_uri)

def verify_jwt_token(token):
    """
    Verify JWT token using JWKS
    
    Args:
        token (str): JWT token to verify
        
    Returns:
        dict: Decoded token payload
        
    Raises:
        AuthenticationError: If token is invalid
    """
    try:
        # Get JWKS client
        jwks_client = get_jwks_client()
        
        # Get the signing key
        signing_key = jwks_client.get_signing_key_from_jwt(token)
        
        # Verify and decode token
        decoded_token = jwt.decode(
            token,
            signing_key.key,
            algorithms=[current_app.config['JWT_ALGORITHM']],
            audience=current_app.config['JWT_AUDIENCE'],
            issuer=current_app.config['OAUTH_ISSUER']
        )
        
        return decoded_token
        
    except jwt.ExpiredSignatureError:
        raise AuthenticationError('Token has expired')
    except jwt.InvalidAudienceError:
        raise AuthenticationError('Invalid token audience')
    except jwt.InvalidIssuerError:
        raise AuthenticationError('Invalid token issuer')
    except jwt.InvalidTokenError as e:
        raise AuthenticationError(f'Invalid token: {str(e)}')
    except Exception as e:
        logger.error(f'Token verification error: {str(e)}')
        raise AuthenticationError('Token verification failed')

def extract_token_from_request():
    """
    Extract JWT token from request headers
    
    Returns:
        str: JWT token or None
    """
    auth_header = request.headers.get('Authorization')
    
    if not auth_header:
        return None
    
    # Check for Bearer token
    if auth_header.startswith('Bearer '):
        return auth_header[7:]  # Remove 'Bearer ' prefix
    
    return None

def auth_required(f):
    """
    Decorator to require authentication for endpoints
    
    Usage:
        @auth_required
        def protected_endpoint():
            return {'message': 'Access granted', 'user': request.user}
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            # Extract token from request
            token = extract_token_from_request()
            
            if not token:
                return jsonify({
                    'error': 'Authentication required',
                    'message': 'No authentication token provided'
                }), 401
            
            # Verify token
            decoded_token = verify_jwt_token(token)
            
            # Store user information in request context
            request.user = {
                'sub': decoded_token.get('sub'),
                'email': decoded_token.get('email'),
                'name': decoded_token.get('name'),
                'preferred_username': decoded_token.get('preferred_username'),
                'roles': decoded_token.get('realm_access', {}).get('roles', []),
                'groups': decoded_token.get('groups', []),
                'token_claims': decoded_token
            }
            
            # Store in Flask g context as well
            g.current_user = request.user
            
            logger.info(f'Authenticated user: {request.user.get("preferred_username", "unknown")}')
            
            return f(*args, **kwargs)
            
        except AuthenticationError as e:
            logger.warning(f'Authentication failed: {str(e)}')
            return jsonify({
                'error': 'Authentication failed',
                'message': str(e)
            }), 401
        except Exception as e:
            logger.error(f'Authentication error: {str(e)}')
            return jsonify({
                'error': 'Authentication error',
                'message': 'Internal authentication error'
            }), 500
    
    return decorated_function

def role_required(*required_roles):
    """
    Decorator to require specific roles for endpoints
    
    Usage:
        @auth_required
        @role_required('admin', 'user')
        def admin_endpoint():
            return {'message': 'Admin access granted'}
    """
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not hasattr(request, 'user'):
                return jsonify({
                    'error': 'Authentication required',
                    'message': 'User not authenticated'
                }), 401
            
            user_roles = request.user.get('roles', [])
            
            # Check if user has any of the required roles
            if not any(role in user_roles for role in required_roles):
                logger.warning(f'Access denied for user {request.user.get("preferred_username")}: '
                             f'required roles {required_roles}, user has {user_roles}')
                return jsonify({
                    'error': 'Access forbidden',
                    'message': f'Required roles: {", ".join(required_roles)}'
                }), 403
            
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator

def get_current_user():
    """
    Get current authenticated user from request context
    
    Returns:
        dict: Current user information or None
    """
    return getattr(request, 'user', None)

def validate_oauth_config():
    """
    Validate OAuth configuration on app startup
    
    Raises:
        ValueError: If configuration is invalid
    """
    required_config = [
        'OAUTH_ISSUER',
        'OAUTH_CLIENT_ID',
        'OAUTH_JWKS_URI'
    ]
    
    missing_config = []
    for config_key in required_config:
        if not current_app.config.get(config_key):
            missing_config.append(config_key)
    
    if missing_config:
        raise ValueError(f'Missing OAuth configuration: {", ".join(missing_config)}')
    
    # Test JWKS endpoint
    try:
        jwks_uri = current_app.config['OAUTH_JWKS_URI']
        response = requests.get(jwks_uri, timeout=5)
        response.raise_for_status()
        logger.info(f'OAuth JWKS endpoint validated: {jwks_uri}')
    except Exception as e:
        logger.error(f'Failed to validate JWKS endpoint: {str(e)}')
        raise ValueError(f'Invalid JWKS endpoint: {jwks_uri}')

{% else -%}
# OAuth not enabled - provide placeholder functions

def auth_required(f):
    """Placeholder decorator when OAuth is disabled"""
    return f

def role_required(*required_roles):
    """Placeholder decorator when OAuth is disabled"""
    def decorator(f):
        return f
    return decorator

def get_current_user():
    """Placeholder function when OAuth is disabled"""
    return None

def validate_oauth_config():
    """Placeholder function when OAuth is disabled"""
    pass

{% endif -%}